## 变量计数器
- 统计变量在过去三十天里的变化情况，统计值划分秒、分、时、天四个刻度区间，每一种刻度逐级递进，进位值按照指定的运算方式对更细的刻度计算统计值；采用`T data[60 + 60 + 24 + 30]`结构保存
- 对外提供一个全局的采样管理器对所有的采样器`Sampler`进行管理，对于所有精度相同的采样器`Sampler`（采样的间隔时间，单位s）采用双向链表管理，通过继承`template <typename T> class LinkNode`实现；外部需要调用全局采样管理器的`Tick()`函数进行驱动，每一次`Tick()`都会检查所有的采样器更新
- 保证一次`Tick()`的时间复杂度为O(1)；事实上所有相同精度的采样器都以双链表的形式保存在一个Slot里，而当前`Tick()`的时机只会使得很少一部分的采样器去`take_sample()`，所以总的时间复杂度并不会是O(N)（遍历所有采样器）
- 调用者只需实现一个形如`template <typename T, BinaryOperation<T> OP, size_t N> class XX_Sampler`的采样器，就可以自动实现采样；其中模板形参T为统计元素类型，OP为针对T类型的二元操作算子，N为统计精度（每过N秒采一次样）

## 视野刷新优化
- 时间轮节点实现懒惰删除，能够对节点复用
- 原本的视野刷新会将当前所有可视对象在一次事件循环里刷新回去，导致一次循环占用时间过长，现做如下优化：
>1. 为可视对象添加优先级的属性，以优先级队列管理，级别高的优先刷回；优先级相同的再按照可视距离划分
>2. 在每一次事件循环里添加刷新数量的上限，确保一次循环不会刷新过多的对象
>3. 如果当前循环帧中没有立即刷新的对象，将其添加到当前对象的缓存中；当下一次事件循环时，缓存中的可视对象自动提升一个优先级
>4. 另外分批刷新还有一个好处在于一些离线对象可能在下一次的事件循环中可以直接删除，不用再刷新

## 游戏平台相关
- 使用Golang和C++混合开发的模式，Golang主要负责HTTP请求的转发和响应的写回和对象存储服务的开发，C++主要负责数据的处理以及一些通用模块的开发
- 数据存储优先访问Redis缓存，缓存层存在于数据处理服务器，保持对逻辑服务器透明
- 整个平台服务为多节点分布式架构，主要分为接入服务、逻辑服务、数据处理服务、列表服务以及对象存储服务；其中各个服务之间互相独立，仅通过列表服务完成各个节点之间的服务发现
- 为了适配C++的已有单进程架构，Golang的HTTP接入层使用无锁队列处理多线程问题；HTTP请求到Golang以后，封装为内部的一个请求结构，放入队列中，然后立即通过socket写事件唤醒C++的接入服务，使得C++去单独处理队列中的请求，避免多线程问题；
- 独立的对象存储服务适配阿里云OSS的带签名URL生成算法，识别并校验对应URL，完成内部存储；为避免大文件超出内存的情况，采用流的方式读缓冲
- 实现JWT-token的生成以及验证算法
